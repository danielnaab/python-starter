"""Service context â€” dependency injection container.

ServiceContext holds all dependencies needed by service functions.
Implemented as a frozen dataclass for immutability and type safety.
"""

from dataclasses import dataclass

{% if include_example_code -%}
from {{ package_name }}.domain.entity import Entity
from {{ package_name }}.domain.repository import Repository


@dataclass(frozen=True)
class ServiceContext:
    """Service layer dependency container.

    Contains all external dependencies needed by service functions.
    Immutable (frozen=True) to ensure thread safety and predictable behavior.

    Pattern:
        - Production: Inject real adapters (PostgresRepository, HTTPClient, etc.)
        - Testing: Inject fakes (FakeRepository, FakeHTTPClient, etc.)

    Attributes:
        repository: Entity persistence (Protocol-based)

    Example:
        # Production context
        ctx = ServiceContext(
            repository=PostgresRepository(connection_string=os.getenv("DATABASE_URL"))
        )

        # Test context
        ctx = ServiceContext(
            repository=FakeRepository()
        )
    """

    repository: Repository[Entity]
{% else -%}
# Import your protocols here
# from {{ package_name }}.domain.repository import Repository


@dataclass(frozen=True)
class ServiceContext:
    """Service layer dependency container.

    Add your dependencies here as Protocol-typed attributes.
    Always use frozen=True for immutability.

    Example:
        from {{ package_name }}.domain.repository import Repository
        from {{ package_name }}.domain.entity import User

        @dataclass(frozen=True)
        class ServiceContext:
            user_repository: Repository[User]
            email_service: EmailService
    """

    pass  # Replace with your dependencies
{% endif -%}
